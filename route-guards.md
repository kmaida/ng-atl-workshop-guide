# Route Guards

We will use route guards to restrict access to pages that should only be viewed by authenticated users. We imported and used our generated route guard files when we set up our [app's routing](/modules-and-routing.md#app-routes). However, the route guards generated by the CLI always return `true`, meaning everyone always has access to them.

Let's change that now.

> **Note**: It's important to note that route guards _alone_ do not confer sufficient security. A client app is, by nature, public. Angular provides ways to restrict views and abstain from loading data for unauthorized users, but we must _always_ ensure that our [API backend](/node-api.md) is secured properly.

## Authentication Guard {#authentication-guard}

Open the `auth.guard.ts` file:

```js
// src/app/auth/auth.guard.ts
import { Injectable } from '@angular/core';
import {
  CanActivate,
  ActivatedRouteSnapshot,
  RouterStateSnapshot
} from '@angular/router';
import { AuthService } from './auth.service';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class AuthGuard implements CanActivate {

  constructor(private auth: AuthService) { }

  canActivate(
    next: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ): Observable<boolean> | Promise<boolean> | boolean {
    if (this.auth.isAuthenticated) {
      return true;
    }
    // Save secure path to redirect to after
    // successful login and prompt to log in
    this.auth.storeAuthRedirect(state.url);
    this.auth.login(true);
    return false;
  }

}
```

Our Auth guard is now created, but it is currently not being used. We'll have to tell our Angular application which routes to use this route guard on. We'll do that in the next section.

## Update Routes

Now let's go back into our routes module and implement the AuthGuard. Update the code to look like this:

```js
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
import { SecureInterceptor } from './auth/secure-interceptor.service';
import { AuthGuard } from './auth/auth.guard';
import { HomeComponent } from './pages/home/home.component';
import { CallbackComponent } from './pages/callback.component';
import { DinosaursComponent } from './pages/dinosaurs/dinosaurs.component';
import { DinosaurDetailsComponent } from './pages/dinosaur-details/dinosaur-details.component';
import { ProfileComponent } from './pages/profile/profile.component';

const routes: Routes = [
  {
    path: 'callback',
    component: CallbackComponent
  },
  {
    path: 'dinosaurs',
    component: DinosaursComponent
  },
  {
    path: 'dinosaur/:name',
    component: DinosaurDetailsComponent,
    canActivate: [
      AuthGuard
    ]
  },
  {
    path: 'profile',
    component: ProfileComponent,
    canActivate: [
      AuthGuard
    ]
  },
  {
    path: '',
    component: HomeComponent,
    pathMatch: 'full'
  }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
```

The Auth guard uses the [canActivate](https://angular.io/api/router/CanActivate) interface \(as we saw in our [app routing](/modules-and-routing.md#app-routes)\) to activate the requested route if conditions are met \(in this case, if the `isAuthenticated` method returns `true`\). If conditions are not met, the user is prompted to log in, and the guarded URL is passed to the `login()` method so that the user can be redirected to this route once they're authenticated.
